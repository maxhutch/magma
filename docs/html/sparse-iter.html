<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: Sparse Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Routines</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sparse-iter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Sparse Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>The MAGMA Sparse-Iter Package </h1>
<p>The sparse-iter package in the MAGMA software stack contains sparse BLAS routines as well as functions to handle the complete iterative solution process of a sparse linear system of equations.</p>
<p>A typical application includes:</p><ul>
<li>an interface passing the linear system to MAGMA</li>
<li>choosing the desired data structures for the respective sparse BLAS functions</li>
<li>sending the data structures to the device</li>
<li>choosing solver, eigensolver, and preconditioner</li>
<li>solving the respective system on the device</li>
<li>passing back the results</li>
</ul>
<p>For each of these steps, multiple options are offered by the MAGMA software stack.</p>
<h1><a class="anchor" id="datastructures"></a>
Sparse Data Structures </h1>
<p>For a more generic programming approach, the sparse data structures (matrices and vectors) are stored in data structures containing all information necessary to access the sparse-BLAS via wrappers: </p><pre class="fragment">struct magma_z_matrix
{
    magma_storage_t    storage_type;            // matrix format - CSR, ELL, SELL-P
    magma_location_t   memory_location;         // CPU or DEV
    magma_symmetry_t   sym;                     // opt: indicate symmetry
    magma_diagorder_t  diagorder_type;          // opt: only needed for factorization matrices
    magma_uplo_t   fill_mode;               // fill mode full/lower/upper
    magma_int_t        num_rows;                // number of rows
    magma_int_t        num_cols;                // number of columns
    magma_int_t        nnz;                     // opt: number of nonzeros
    magma_int_t        max_nnz_row;             // opt: max number of nonzeros in one row
    magma_int_t        diameter;                // opt: max distance of entry from main diagonal
    union {
        magmaDoubleComplex      *val;           // array containing values in CPU case
        magmaDoubleComplex_ptr  dval;           // array containing values in DEV case
    };
    union {
        magmaDoubleComplex      *diag;          // opt: diagonal entries in CPU case
        magmaDoubleComplex_ptr  ddiag;          // opt: diagonal entries in DEV case
    };
    union {
        magma_index_t           *row;           // opt: row pointer CPU case
        magmaIndex_ptr          drow;           // opt: row pointer DEV case
    };
    union {
        magma_index_t           *rowidx;        // opt: array containing row indices CPU case
        magmaIndex_ptr          drowidx;        // opt: array containing row indices DEV case
    };
    union {
        magma_index_t           *col;           // opt: array containing col indices CPU case
        magmaIndex_ptr          dcol;           // opt: array containing col indices DEV case
    };
    union {
        magma_index_t           *list;          // opt: linked list pointing to next element
        magmaIndex_ptr          dlist;          // opt: linked list pointing to next element
    };
    magma_index_t      *blockinfo;              // opt: for BCSR format CPU case
    magma_int_t        blocksize;               // opt: info for SELL-P/BCSR
    magma_int_t        numblocks;               // opt: info for SELL-P/BCSR
    magma_int_t        alignment;               // opt: info for SELL-P/BCSR
    magma_order_t      major;                   // opt: row/col major for dense matrices
    magma_int_t        ld;                      // opt: leading dimension for dense
} magma_z_matrix;
</pre><p>The purpose of the unions (e.g. for the val array) is to support different hardware platforms, where the magmaXXX_ptr is adapted to the respective device characteristics.</p>
<p>For sparse matrices, the main formats are CSR, ELL and the MAGMA-specific SELL-P. Generally, the sparse-BLAS routines provide for these the best performance.</p>
<p>Without specifying the storage type, the memory location or the dimension of the matrix, the sparse matrix vector product can then be used via the wrapper: </p><pre class="fragment">magma_z_spmv(
        magmaDoubleComplex alpha,
        magma_z_matrix A,
        magma_z_matrix x,
        magmaDoubleComplex beta,
        magma_z_matrix y,
        magma_queue_t queue );
</pre><h1><a class="anchor" id="io"></a>
Sparse I/O </h1>
<p>A sparse matrix stored in mtx format can be read from disk via the function: </p><pre class="fragment">magma_z_csr_mtx(
        magma_z_matrix *A,
        const char *filename,
        magma_queue_t queue );
</pre><p>A sparse linear system of dimension mxn present in main memory can be passed to MAGMA via the function: </p><pre class="fragment">magma_zcsrset(
        magma_int_t m,
        magma_int_t n,
        magma_index_t *row,
        magma_index_t *col,
        magmaDoubleComplex *val,
        magma_z_matrix *A,
        magma_queue_t queue );
</pre><p>where row, col, val contain the matrix in CSR format.</p>
<p>If the matrix is already present in DEV memory, the corresponding function is </p><pre class="fragment">magma_zcsrset_gpu(
    magma_int_t m,
    magma_int_t n,
    magmaIndex_ptr row,
    magmaIndex_ptr col,
    magmaDoubleComplex_ptr val,
    magma_z_matrix *A,
    magma_queue_t queue );
</pre><p>Similarly, matrices handled in MAGMA can be returned via the functions </p><pre class="fragment">magma_zcsrget(
    magma_z_matrix A,
    magma_int_t *m,
    magma_int_t *n,
    magma_index_t **row,
    magma_index_t **col,
    magmaDoubleComplex **val,
    magma_queue_t queue );

magma_zcsrget_gpu(
    magma_z_matrix A,
    magma_int_t *m,
    magma_int_t *n,
    magmaIndex_ptr *row,
    magmaIndex_ptr *col,
    magmaDoubleComplex_ptr *val,
    magma_queue_t queue );

respectively

write_z_csrtomtx(
    magma_z_matrix A,
    const char *filename,
    magma_queue_t queue );
</pre><p>Additionally, MAGMA contains routines to generate stencil discretizations of different kind.</p>
<p>Vectors are handled as dense matrices (Magma_DENSE) and can be initialized inside MAGMA via </p><pre class="fragment">magma_z_vinit(
    magma_z_matrix *x,
    magma_location_t memory_location,
    magma_int_t num_rows,
    magmaDoubleComplex values,
    magma_queue_t queue );
</pre><p>where ''memory_location'' sets the location (Magma_CPU or Magma_DEV). Also, vectors can be read from file via </p><pre class="fragment">magma_z_vread(
    magma_z_matrix *x,
    magma_int_t length,
    char * filename,
    magma_queue_t queue );
</pre><p>or - in case of a block of sparse vectors stored as CSR matrix - via </p><pre class="fragment">magma_z_vspread(
    magma_z_matrix *x,
    const char * filename,
    magma_queue_t queue );
</pre><p>or passed from/to main memory: </p><pre class="fragment">magma_zvset(
    magma_int_t m,
    magma_int_t n,
    magmaDoubleComplex *val,
    magma_z_matrix *b,
    magma_queue_t queue );

magma_zvget(
    magma_z_matrix b
    magma_int_t *m,
    magma_int_t *n,
    magmaDoubleComplex **val,
    magma_queue_t queue );
</pre><h1><a class="anchor" id="formats"></a>
Matrix Formats </h1>
<p>To convert a matrix from one into another format, the CPU-based routine </p><pre class="fragment">magma_z_mconvert(
    magma_z_matrix A,
    magma_z_matrix *B,
    magma_storage_t old_format,
    magma_storage_t new_format,
    magma_queue_t queue );
</pre><p>can be used where old_format and new_format determine the specific conversion.</p>
<h1><a class="anchor" id="memorhandling"></a>
Memory Handling </h1>
<p>All iterative solvers and eigensolvers included in the sparse-iter package work on the device. Hence, it is required to send the respective data structures to the device for solving, and back to access the solution. The functions </p><pre class="fragment">magma_z_mtransfer(
    magma_z_matrix A,
    magma_z_matrix *B,
    magma_location_t src,
    magma_location_t dst,
    magma_queue_t queue );

magma_z_vtransfer(
    magma_z_matrix x,
    magma_z_matrix *y,
    magma_location_t src,
    magma_location_t dst,
    magma_queue_t queue );
</pre><p>allow any data copy operation - from host to device, device to device, device to host or host to host.</p>
<p>Linear algebra objects can be deallocated via </p><pre class="fragment">magma_z_mfree(
    magma_z_matrix *A,
    magma_queue_t queue );
</pre><h1><a class="anchor" id="sparsesolvers"></a>
Iterative Solvers </h1>
<p>The sparse-iter package contains a variety of linear solvers, eigensolvers, and preconditioners. The standard procedure to call a solver is to pass the linear algebra objects (located on the device) and a structure called magma_z_solver_par (respectively and magma_z_precond_par) controlling the iterative solver and collecting information during the execution: </p><pre class="fragment">struct magma_z_solver_par
{
    magma_solver_type  solver;                  // solver type
    magma_int_t        version;                 // sometimes there are different versions
    double             atol;                     // absolute residual stopping criterion
    double             rtol;                    // relative residual stopping criterion
    magma_int_t        maxiter;                 // upper iteration limit
    magma_int_t        restart;                 // for GMRES
    magma_ortho_t      ortho;                   // for GMRES
    magma_int_t        numiter;                 // feedback: number of needed iterations
    double             init_res;                // feedback: initial residual
    double             final_res;               // feedback: final residual
    double             iter_res;                // feedback: iteratively computed residual
    real_Double_t      runtime;                 // feedback: runtime needed
    real_Double_t      *res_vec;                // feedback: array containing residuals
    real_Double_t      *timing;                 // feedback: detailed timing
    magma_int_t        verbose;                 // print residual ever 'verbose' iterations
    magma_int_t        num_eigenvalues;         // number of EV for eigensolvers
    magma_int_t        ev_length;               // needed for framework
    double             *eigenvalues;            // feedback: array containing eigenvalues
    magmaDoubleComplex_ptr      eigenvectors;   // feedback: array containing eigenvectors on DEV
    magma_int_t        info;                    // feedback: did the solver converge etc.
</pre><hr/>
<p> the input for verbose is: 0 = production mode k&gt;0 = convergence and timing is monitored in *res_vec and *timeing every k-th iteration</p>
<p>the output of info is: 0 = convergence (stopping criterion met) -1 = no convergence </p><h2>-2 = convergence but stopping criterion not met within maxiter </h2>
<p>} magma_z_solver_par;</p>
<p>These entities can either be initialized manually, or via the function </p><pre class="fragment">magma_zsolverinfo_init(
    magma_z_solver_par *solver_par,
    magma_z_preconditioner *precond_par,
    magma_queue_t queue );
</pre><p>setting them to some default values. For eigensolvers, the workspace needed for the eigenvectors has to be allocated consistent with the matrix dimension, which requires additionally calling </p><pre class="fragment">magma_zeigensolverinfo_init(
    magma_z_solver_par *solver_par,
    magma_queue_t queue );
</pre><p>after setting solver_par.ev_length and solver_par.num_eigenvalues to the correct numbers.</p>
<p>For the preconditioner configuration, a similar structure is used:</p>
<p>typedef struct magma_z_preconditioner { magma_solver_type solver; magma_solver_type trisolver; magma_int_t levels; magma_int_t sweeps; magma_int_t pattern; magma_int_t bsize; magma_int_t offset; magma_precision format; double atol; double rtol; magma_int_t maxiter; magma_int_t restart; magma_int_t numiter; magma_int_t spmv_count; double init_res; double final_res; real_Double_t runtime; // feedback: preconditioner runtime real_Double_t setuptime; // feedback: preconditioner setup time magma_z_matrix M; magma_z_matrix L; magma_z_matrix LT; magma_z_matrix U; magma_z_matrix UT; magma_z_matrix LD; magma_z_matrix UD; magma_z_matrix d; magma_z_matrix d2; magma_z_matrix work1; magma_z_matrix work2; magma_int_t* int_array_1; magma_int_t* int_array_2; cusparseSolveAnalysisInfo_t cuinfo; // for cuSPARSE ILU cusparseSolveAnalysisInfo_t cuinfoL; // for cuSPARSE ILU cusparseSolveAnalysisInfo_t cuinfoLT; // for cuSPARSE ILU cusparseSolveAnalysisInfo_t cuinfoU; // for cuSPARSE ILU cusparseSolveAnalysisInfo_t cuinfoUT; // for cuSPARSE ILU } magma_z_preconditioner;</p>
<p>An easy way to access the data collected during a solver execution is given by the function </p><pre class="fragment">magma_zsolverinfo(
    magma_z_solver_par *solver_par,
    magma_z_preconditioner *precond_par,
    magma_queue_t queue );
</pre><p>After completion, </p><pre class="fragment">magma_zsolverinfo_free(
    magma_z_solver_par *solver_par,
    magma_z_preconditioner *precond,
    magma_queue_t queue );
</pre><p>deallocates all memory used within the solver and preconditioner structure.</p>
<p>A solver can be called via the wrapper </p><pre class="fragment">magma_z_solver(
    magma_z_matrix A, magma_z_matrix b,
    magma_z_matrix *x, magma_zopts *zopts,
    magma_queue_t queue );
</pre><p>where zopts is a structure containing both, the solver and the preconditioner information: struct magma_zopts{ magma_z_solver_par solver_par; magma_z_preconditioner precond_par; magma_storage_t input_format; int blocksize; int alignment; magma_storage_t output_format; magma_location_t input_location; magma_location_t output_location; magma_scale_t scaling; }magma_zopts;</p>
<p>All entities of this structure can be initialized from command line by calling </p><pre class="fragment">magma_zparse_opts(
    int argc,
    char** argv,
    magma_zopts *opts,
    int *matrices,
    magma_queue_t queue );
</pre><h1><a class="anchor" id="sparseexample"></a>
Example </h1>
<p>Especially when using sparse-iter for the first time, the easiest way to get familiar with the package is to use and modify one of the predefined testers.</p>
<p>In the following example we assume to have an application coded in C and running in double precision that at some instance requires solving a linear system of the form Ax=b, where A and b are generated within the application. Furthermore, we assume that the matrix A is in CSR format and stored in row/col/val, and the vector b is stored in valb. These entities are passed to MAGMA-sparse. In the end, we want the solution passed back to the application in the vector valx.</p>
<p>initialize MAGMA-sparse and create some LA objects magma_dopts dopts; magma_queue_t queue; magma_queue_create( 0, &amp;queue ); magma_d_matrix A, A_d, x, x_d, b, b_d;</p>
<p>pass linear system to MAGMA-sparse magma_dcsrset( m, n, row, col, val, &amp;A, queue ); magma_dvset( m, n, valb, &amp;b, queue );</p>
<p>copy the linear system to the device magma_d_vtransfer( b, &amp;b_d, Magma_CPU, Magma_DEV, queue ); magma_d_mtransfer( A, &amp;A_d, Magma_CPU, Magma_DEV, queue ); allocate solution vector - on device magma_d_vinit( &amp;x_d, Magma_DEV, A.num_cols, one, queue );</p>
<p>configure solver dopts.solver_par.solver = Magma_PGMRES; dopts.solver_par.restart = 30; dopts.solver_par.rtol = 1e-10; magma_dsolverinfo_init( &amp;dopts.solver_par, &amp;dopts.precond_par, queue );</p>
<p>configure the preconditioner dopts.precond_par.solver = Magma_ILU; dopts.precond_par.levels = 0; dopts.precond_par.trisolver = Magma_CUSOLVE; magma_d_precondsetup( A, b, &amp;dopts.solver_par, &amp;dopts.precond_par, queue );</p>
<p>solve the linear system magma_d_solver( B_d, b_d, &amp;x_d, &amp;dopts, queue );</p>
<p>copy the solution vector back to the host and pass it back to the application magma_d_mtransfer( x_d, &amp;x, Magma_DEV, Magma_CPU, queue ); magma_dvget( x, &amp;m, &amp;n, &amp;valx, queue );</p>
<p>clean up the memory magma_dsolverinfo_free( &amp;dopts.solver_par, &amp;dopts.precond_par, queue ); magma_d_mfree(&amp;A_d, queue ); magma_d_mfree(&amp;A, queue ); magma_d_mfree(&amp;x_d, queue ); magma_d_mfree(&amp;b_d, queue ); magma_d_mfree(&amp;b, queue );</p>
<p>finalize MAGMA <a class="el" href="group__magma__queue.html#gacd3182186abc4a99def8a61a48af43fc" title="Destroys a queue, freeing its resources. ">magma_queue_destroy( queue )</a>; <a class="el" href="group__magma__init.html#gae7463bee75a4c738929f1169b930938b" title="Frees information used by the MAGMA library. ">magma_finalize()</a>; </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
