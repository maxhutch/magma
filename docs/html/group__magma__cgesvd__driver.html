<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MAGMA: single-complex precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>single-complex precision<br/>
<small>
[<a class="el" href="group__magma__gesvd__driver.html">SVD: driver</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgesvd__driver.html#gabdfa5370c04558dc13a6431907fe0c05">magma_cgesdd</a> (magma_vec_t jobz, magma_int_t m, magma_int_t n, magmaFloatComplex *A, magma_int_t lda, float *s, magmaFloatComplex *U, magma_int_t ldu, magmaFloatComplex *VT, magma_int_t ldvt, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *iwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CGESDD computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and right singular vectors, by using divide-and-conquer method.  <a href="#gabdfa5370c04558dc13a6431907fe0c05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgesvd__driver.html#ga4fabaf4f2eb541d45768429d7ef8979a">magma_cgesvd</a> (magma_vec_t jobu, magma_vec_t jobvt, magma_int_t m, magma_int_t n, magmaFloatComplex *A, magma_int_t lda, float *s, magmaFloatComplex *U, magma_int_t ldu, magmaFloatComplex *VT, magma_int_t ldvt, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CGESVD computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and/or right singular vectors.  <a href="#ga4fabaf4f2eb541d45768429d7ef8979a"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabdfa5370c04558dc13a6431907fe0c05"></a><!-- doxytag: member="cgesdd.cpp::magma_cgesdd" ref="gabdfa5370c04558dc13a6431907fe0c05" args="(magma_vec_t jobz, magma_int_t m, magma_int_t n, magmaFloatComplex *A, magma_int_t lda, float *s, magmaFloatComplex *U, magma_int_t ldu, magmaFloatComplex *VT, magma_int_t ldvt, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *iwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgesdd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CGESDD computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and right singular vectors, by using divide-and-conquer method. </p>
<p>The SVD is written</p>
<p>A = U * SIGMA * conjugate-transpose(V)</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M unitary matrix, and V is an N-by-N unitary matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns VT = V**H, not V.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobz</em>&nbsp;</td><td>magma_vec_t Specifies options for computing all or part of the matrix U:</p>
<ul>
<li>= MagmaAllVec: all M columns of U and all N rows of V**H are returned in the arrays U and VT;</li>
<li>= MagmaSomeVec: the first min(M,N) columns of U and the first min(M,N) rows of V**H are returned in the arrays U and VT;</li>
<li>= MagmaOverwriteVec: If M &gt;= N, the first N columns of U are overwritten on the array A and all rows of V**H are returned in the array VT; otherwise, all columns of U are returned in the array U and the first M rows of V**H are overwritten on the array A;</li>
<li>= MagmaNoVec: no columns of U or rows of V**H are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>INTEGER The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if JOBZ = MagmaOverwriteVec, if M &gt;= N, A is overwritten with the first N columns of U (the left singular vectors, stored columnwise); otherwise, A is overwritten with the first M rows of V**H (the right singular vectors, stored rowwise).</li>
<li>if JOBZ != MagmaOverwriteVec, the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s</em>&nbsp;</td><td>REAL array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i+1).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>U</em>&nbsp;</td><td>COMPLEX array, dimension (LDU,UCOL) UCOL = M if JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N; UCOL = min(M,N) if JOBZ = MagmaSomeVec.</p>
<ul>
<li>If JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N, U contains the M-by-M unitary matrix U;</li>
<li>if JOBZ = MagmaSomeVec, U contains the first min(M,N) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBZ = MagmaOverwriteVec and M &gt;= N, or JOBZ = MagmaNoVec, U is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldu</em>&nbsp;</td><td>INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBZ = MagmaSomeVec or MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N, LDU &gt;= M.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>VT</em>&nbsp;</td><td>COMPLEX array, dimension (LDVT,N)</p>
<ul>
<li>If JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &gt;= N, VT contains the N-by-N unitary matrix V**H;</li>
<li>if JOBZ = MagmaSomeVec, VT contains the first min(M,N) rows of V**H (the right singular vectors, stored rowwise);</li>
<li>if JOBZ = MagmaOverwriteVec and M &lt; N, or JOBZ = MagmaNoVec, VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvt</em>&nbsp;</td><td>INTEGER The leading dimension of the array VT. LDVT &gt;= 1; if JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &gt;= N, LDVT &gt;= N; if JOBZ = MagmaSomeVec, LDVT &gt;= min(M,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) COMPLEX array, dimension (MAX(1,lwork)) On exit, if INFO = 0, WORK[0] returns the optimal lwork.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The dimension of the array WORK. Let x = max(M,N) and y = min(M,N). The optimal block size nb can be obtained through magma_get_dgesvd_nb(N). The threshold for x &gt;&gt; y currently is x &gt;= int( y*17/9 ). Required size different than in LAPACK.* In most cases, these sizes should give optimal performance for both MAGMA and LAPACK.</p>
<ul>
<li>If JOBZ = MagmaNoVec, if x &gt;&gt; y, LWORK &gt;= 2*y + (2*y)*nb; otherwise, LWORK &gt;= 2*y + (x+y)*nb.</li>
<li>If JOBZ = MagmaOverwriteVec, if x &gt;&gt; y, LWORK &gt;= 2*y*y + 2*y + (2*y)*nb; otherwise, LWORK &gt;= 2*y + max( (x+y)*nb, y*y + x ), prefer LWORK &gt;= 2*y + max( (x+y)*nb, x*y + y*nb ).</li>
<li>If JOBZ = MagmaSomeVec, if x &gt;&gt; y, LWORK &gt;= y*y + 2*y + (2*y)*nb; otherwise, LWORK &gt;= 2*y + (x+y)*nb.</li>
<li>If JOBZ = MagmaAllVec, if x &gt;&gt; y, LWORK &gt;= y*y + 2*y + max( (2*y)*nb, x ), prefer LWORK &gt;= y*y + 2*y + max( (2*y)*nb, x*nb ); otherwise, LWORK &gt;= 2*y + (x+y)*nb. <br/>
 If lwork = -1, a workspace query is assumed. The optimal size for the WORK array is calculated and stored in WORK[0], and no other work except argument checking is performed.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rwork</em>&nbsp;</td><td>(workspace) REAL array, dimension (MAX(1,LRWORK)) Let x = max(M,N) and y = min(M,N). These sizes should work for both MAGMA and LAPACK. If JOBZ = MagmaNoVec, LRWORK &gt;= 5*y. If JOBZ != MagmaNoVec, if x &gt;&gt; y, LRWORK &gt;= 5*y*y + 5*y; otherwise, LRWORK &gt;= max( 5*y*y + 5*y, 2*x*y + 2*y*y + y ). <br/>
 For JOBZ = MagmaNoVec, some implementations seem to have a bug requiring LRWORK &gt;= 7*y in some cases.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iwork</em>&nbsp;</td><td>(workspace) INTEGER array, dimension (8*min(M,N))</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The updating process of SBDSDC did not converge.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="ga4fabaf4f2eb541d45768429d7ef8979a"></a><!-- doxytag: member="cgesvd.cpp::magma_cgesvd" ref="ga4fabaf4f2eb541d45768429d7ef8979a" args="(magma_vec_t jobu, magma_vec_t jobvt, magma_int_t m, magma_int_t n, magmaFloatComplex *A, magma_int_t lda, float *s, magmaFloatComplex *U, magma_int_t ldu, magmaFloatComplex *VT, magma_int_t ldvt, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgesvd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>jobvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CGESVD computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and/or right singular vectors. </p>
<p>The SVD is written</p>
<p>A = U * SIGMA * conjugate-transpose(V)</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M unitary matrix, and V is an N-by-N unitary matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns V**H, not V.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobu</em>&nbsp;</td><td>magma_vec_t Specifies options for computing all or part of the matrix U:</p>
<ul>
<li>= MagmaAllVec: all M columns of U are returned in array U:</li>
<li>= MagmaSomeVec: the first min(m,n) columns of U (the left singular vectors) are returned in the array U;</li>
<li>= MagmaOverwriteVec: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A;</li>
<li>= MagmaNoVec: no columns of U (no left singular vectors) are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobvt</em>&nbsp;</td><td>magma_vec_t Specifies options for computing all or part of the matrix V**H:</p>
<ul>
<li>= MagmaAllVec: all N rows of V**H are returned in the array VT;</li>
<li>= MagmaSomeVec: the first min(m,n) rows of V**H (the right singular vectors) are returned in the array VT;</li>
<li>= MagmaOverwriteVec: the first min(m,n) rows of V**H (the right singular vectors) are overwritten on the array A;</li>
<li>= MagmaNoVec: no rows of V**H (no right singular vectors) are computed. <br/>
 JOBVT and JOBU cannot both be MagmaOverwriteVec.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>INTEGER The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if JOBU = MagmaOverwriteVec, A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBVT = MagmaOverwriteVec, A is overwritten with the first min(m,n) rows of V**H (the right singular vectors, stored rowwise);</li>
<li>if JOBU != MagmaOverwriteVec and JOBVT != MagmaOverwriteVec, the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i+1).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>U</em>&nbsp;</td><td>COMPLEX array, dimension (LDU,UCOL) (LDU,M) if JOBU = MagmaAllVec or (LDU,min(M,N)) if JOBU = MagmaSomeVec.</p>
<ul>
<li>If JOBU = MagmaAllVec, U contains the M-by-M unitary matrix U;</li>
<li>if JOBU = MagmaSomeVec, U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBU = MagmaNoVec or MagmaOverwriteVec, U is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldu</em>&nbsp;</td><td>INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBU = MagmaSomeVec or MagmaAllVec, LDU &gt;= M.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>VT</em>&nbsp;</td><td>COMPLEX array, dimension (LDVT,N)</p>
<ul>
<li>If JOBVT = MagmaAllVec, VT contains the N-by-N unitary matrix V**H;</li>
<li>if JOBVT = MagmaSomeVec, VT contains the first min(m,n) rows of V**H (the right singular vectors, stored rowwise);</li>
<li>if JOBVT = MagmaNoVec or MagmaOverwriteVec, VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvt</em>&nbsp;</td><td>INTEGER The leading dimension of the array VT. LDVT &gt;= 1;</p>
<ul>
<li>if JOBVT = MagmaAllVec, LDVT &gt;= N;</li>
<li>if JOBVT = MagmaSomeVec, LDVT &gt;= min(M,N).</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the required LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The dimension of the array WORK. LWORK &gt;= (M+N)*nb + 2*min(M,N). For optimum performance with some paths (m &gt;&gt; n and jobu=A,S,O; or n &gt;&gt; m and jobvt=A,S,O), LWORK &gt;= (M+N)*nb + 2*min(M,N) + 2*min(M,N)**2 (see comments inside code). <br/>
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the required size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rwork</em>&nbsp;</td><td>(workspace) DOUBLE_PRECISION array, dimension (5*min(M,N)) On exit, if INFO &gt; 0, RWORK(1:MIN(M,N)-1) contains the unconverged superdiagonal elements of an upper bidiagonal matrix B whose diagonal is in S (not necessarily sorted). B satisfies A = U * B * VT, so it has the same singular values as A, and singular vectors related by U and VT.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if CBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of RWORK above for details. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Nov 2014 for MAGMA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
