<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MAGMA: single-complex precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>single-complex precision<br/>
<small>
[<a class="el" href="group__magma__geev__comp.html">Non-symmetric eigenvalue: computational</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#gabb038016a7f499c46c604650880be711">magma_cgehrd</a> (magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magmaFloatComplex_ptr dT, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CGEHRD reduces a COMPLEX general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H .  <a href="#gabb038016a7f499c46c604650880be711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#ga1ef7dda30b2691ad6f37ec76082dc641">magma_cgehrd2</a> (magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CGEHRD2 reduces a COMPLEX general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H .  <a href="#ga1ef7dda30b2691ad6f37ec76082dc641"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#ga99a6ce9ed9c039351a24148bd635efd5">magma_cgehrd_m</a> (magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magmaFloatComplex *T, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CGEHRD reduces a COMPLEX general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H .  <a href="#ga99a6ce9ed9c039351a24148bd635efd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#gaabe4c9003c1b68ccea6e5a64875a3e6f">magma_ctrevc3</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaFloatComplex *T, magma_int_t ldt, magmaFloatComplex *VL, magma_int_t ldvl, magmaFloatComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CTREVC3 computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T.  <a href="#gaabe4c9003c1b68ccea6e5a64875a3e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#gab683d09689da0d357666194408411673">magma_ctrevc3_mt</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaFloatComplex *T, magma_int_t ldt, magmaFloatComplex *VL, magma_int_t ldvl, magmaFloatComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CTREVC3_MT computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T.  <a href="#gab683d09689da0d357666194408411673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#ga09a558890c516640ef81f1205b691310">magma_cunghr</a> (magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CUNGHR generates a COMPLEX unitary matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by CGEHRD:.  <a href="#ga09a558890c516640ef81f1205b691310"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cgeev__comp.html#ga837c62a892423c53dc421c473c4aca92">magma_cunghr_m</a> (magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *T, magma_int_t nb, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CUNGHR generates a COMPLEX unitary matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by CGEHRD:.  <a href="#ga837c62a892423c53dc421c473c4aca92"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabb038016a7f499c46c604650880be711"></a><!-- doxytag: member="cgehrd.cpp::magma_cgehrd" ref="gabb038016a7f499c46c604650880be711" args="(magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magmaFloatComplex_ptr dT, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgehrd </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&nbsp;</td>
          <td class="paramname"> <em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CGEHRD reduces a COMPLEX general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H . </p>
<p>This version stores the triangular matrices used in the factorization so that they can be applied directly (i.e., without being recomputed) later. As a result, the application of Q is much faster.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ilo</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ihi</em>&nbsp;</td><td>INTEGER It is assumed that A is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally set by a previous call to CGEBAL; otherwise they should be set to 1 and N respectively. See Further Details. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the N-by-N general matrix to be reduced. On exit, the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg matrix H, and the elements below the first subdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>COMPLEX array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to zero.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) COMPLEX array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The length of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize. <br/>
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dT</em>&nbsp;</td><td>COMPLEX array on the GPU, dimension NB*N, where NB is the optimal blocksize. It stores the NB*NB blocks of the triangular T matrices used in the reduction.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- The matrix Q is represented as a product of (ihi-ilo) elementary reflectors</p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a complex scalar, and v is a complex vector with v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on exit in A(i+2:ihi,i), and tau in TAU(i).</p>
<p>The contents of A are illustrated by the following example, with n = 7, ilo = 2 and ihi = 6:</p>
<div class="fragment"><pre class="fragment">
    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )
    </pre></div><p>where a denotes an element of the original matrix A, h denotes a modified element of the upper Hessenberg matrix H, and vi denotes an element of the vector defining H(i).</p>
<p>This implementation follows the hybrid algorithm and notations described in</p>
<p>S. Tomov and J. Dongarra, "Accelerating the reduction to upper Hessenberg
    form through hybrid GPU-based computing," University of Tennessee Computer Science Technical Report, UT-CS-09-642 (also LAPACK Working Note 219), May 24, 2009.</p>
<p>This version stores the T matrices in dT, for later use in magma_cunghr. </p>

</div>
</div>
<a class="anchor" id="ga1ef7dda30b2691ad6f37ec76082dc641"></a><!-- doxytag: member="cgehrd2.cpp::magma_cgehrd2" ref="ga1ef7dda30b2691ad6f37ec76082dc641" args="(magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgehrd2 </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CGEHRD2 reduces a COMPLEX general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ilo</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ihi</em>&nbsp;</td><td>INTEGER It is assumed that A is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally set by a previous call to CGEBAL; otherwise they should be set to 1 and N respectively. See Further Details. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the N-by-N general matrix to be reduced. On exit, the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg matrix H, and the elements below the first subdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>COMPLEX array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to zero.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) COMPLEX array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The length of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize. <br/>
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- The matrix Q is represented as a product of (ihi-ilo) elementary reflectors</p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a complex scalar, and v is a complex vector with v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on exit in A(i+2:ihi,i), and tau in TAU(i).</p>
<p>The contents of A are illustrated by the following example, with n = 7, ilo = 2 and ihi = 6:</p>
<div class="fragment"><pre class="fragment">
    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )
    </pre></div><p>where a denotes an element of the original matrix A, h denotes a modified element of the upper Hessenberg matrix H, and vi denotes an element of the vector defining H(i).</p>
<p>This implementation follows the hybrid algorithm and notations described in</p>
<p>S. Tomov and J. Dongarra, "Accelerating the reduction to upper Hessenberg
    form through hybrid GPU-based computing," University of Tennessee Computer Science Technical Report, UT-CS-09-642 (also LAPACK Working Note 219), May 24, 2009. </p>

</div>
</div>
<a class="anchor" id="ga99a6ce9ed9c039351a24148bd635efd5"></a><!-- doxytag: member="cgehrd_m.cpp::magma_cgehrd_m" ref="ga99a6ce9ed9c039351a24148bd635efd5" args="(magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magmaFloatComplex *T, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgehrd_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CGEHRD reduces a COMPLEX general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H . </p>
<p>This version stores the triangular matrices used in the factorization so that they can be applied directly (i.e., without being recomputed) later. As a result, the application of Q is much faster.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ilo</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ihi</em>&nbsp;</td><td>INTEGER It is assumed that A is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally set by a previous call to CGEBAL; otherwise they should be set to 1 and N respectively. See Further Details. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the N-by-N general matrix to be reduced. On exit, the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg matrix H, and the elements below the first subdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>COMPLEX array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to zero.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) COMPLEX array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The length of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize. <br/>
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>T</em>&nbsp;</td><td>COMPLEX array, dimension NB*N, where NB is the optimal blocksize. It stores the NB*NB blocks of the triangular T matrices used in the reduction.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- The matrix Q is represented as a product of (ihi-ilo) elementary reflectors</p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a complex scalar, and v is a complex vector with v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on exit in A(i+2:ihi,i), and tau in TAU(i).</p>
<p>The contents of A are illustrated by the following example, with n = 7, ilo = 2 and ihi = 6:</p>
<div class="fragment"><pre class="fragment">
    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )
    </pre></div><p>where a denotes an element of the original matrix A, h denotes a modified element of the upper Hessenberg matrix H, and vi denotes an element of the vector defining H(i).</p>
<p>This implementation follows the hybrid algorithm and notations described in</p>
<p>S. Tomov and J. Dongarra, "Accelerating the reduction to upper Hessenberg
    form through hybrid GPU-based computing," University of Tennessee Computer Science Technical Report, UT-CS-09-642 (also LAPACK Working Note 219), May 24, 2009.</p>
<p>This version stores the T matrices, for later use in magma_cunghr. </p>

</div>
</div>
<a class="anchor" id="gaabe4c9003c1b68ccea6e5a64875a3e6f"></a><!-- doxytag: member="ctrevc3.cpp::magma_ctrevc3" ref="gaabe4c9003c1b68ccea6e5a64875a3e6f" args="(magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaFloatComplex *T, magma_int_t ldt, magmaFloatComplex *VL, magma_int_t ldvl, magmaFloatComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ctrevc3 </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&nbsp;</td>
          <td class="paramname"> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CTREVC3 computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**H)*T = w*(y**H)</p>
<p>where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>side</em>&nbsp;</td><td>magma_side_t</p>
<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>howmany</em>&nbsp;</td><td>magma_vec_t</p>
<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>select</em>&nbsp;</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. The eigenvector corresponding to the j-th eigenvalue is computed if select[j] = true. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>T</em>&nbsp;</td><td>COMPLEX array, dimension (ldt,n) The upper triangular matrix T. modified, but restored on exit.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldt</em>&nbsp;</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>VL</em>&nbsp;</td><td>COMPLEX array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. Not referenced if side = MagmaRight.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvl</em>&nbsp;</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>VR</em>&nbsp;</td><td>COMPLEX array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvr</em>&nbsp;</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mm</em>&nbsp;</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mout</em>&nbsp;</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected eigenvector occupies one column.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>COMPLEX array, dimension (max(1,lwork))</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,2*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>rwork</em>&nbsp;</td><td>float array, dimension (n)</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="gab683d09689da0d357666194408411673"></a><!-- doxytag: member="ctrevc3_mt.cpp::magma_ctrevc3_mt" ref="gab683d09689da0d357666194408411673" args="(magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaFloatComplex *T, magma_int_t ldt, magmaFloatComplex *VL, magma_int_t ldvl, magmaFloatComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ctrevc3_mt </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&nbsp;</td>
          <td class="paramname"> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CTREVC3_MT computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**H)*T = w*(y**H)</p>
<p>where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation. This uses a multi-threaded (mt) implementation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>side</em>&nbsp;</td><td>magma_side_t</p>
<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>howmany</em>&nbsp;</td><td>magma_vec_t</p>
<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>select</em>&nbsp;</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. The eigenvector corresponding to the j-th eigenvalue is computed if select[j] = true. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>T</em>&nbsp;</td><td>COMPLEX array, dimension (ldt,n) The upper triangular matrix T. Unlike LAPACK's ctrevc, T is not modified, not even temporarily.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldt</em>&nbsp;</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>VL</em>&nbsp;</td><td>COMPLEX array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. Not referenced if side = MagmaRight.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvl</em>&nbsp;</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>VR</em>&nbsp;</td><td>COMPLEX array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvr</em>&nbsp;</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mm</em>&nbsp;</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mout</em>&nbsp;</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected eigenvector occupies one column.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>COMPLEX array, dimension (max(1,lwork))</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,2*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>rwork</em>&nbsp;</td><td>float array, dimension (n)</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="ga09a558890c516640ef81f1205b691310"></a><!-- doxytag: member="cunghr.cpp::magma_cunghr" ref="ga09a558890c516640ef81f1205b691310" args="(magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex_ptr dT, magma_int_t nb, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunghr </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&nbsp;</td>
          <td class="paramname"> <em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CUNGHR generates a COMPLEX unitary matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by CGEHRD:. </p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix Q. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ilo</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ihi</em>&nbsp;</td><td>INTEGER ILO and IHI must have the same values as in the previous call of CGEHRD. Q is equal to the unit matrix except in the submatrix Q(ilo+1:ihi,ilo+1:ihi). 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by CGEHRD. On exit, the N-by-N unitary matrix Q.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>COMPLEX array, dimension (N-1) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEHRD.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dT</em>&nbsp;</td><td>COMPLEX array on the GPU device. DT contains the T matrices used in blocking the elementary reflectors H(i), e.g., this can be the 9th argument of magma_cgehrd.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>INTEGER This is the block size used in CGEHRD, and correspondingly the size of the T matrices, used in the factorization, and stored in DT.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga837c62a892423c53dc421c473c4aca92"></a><!-- doxytag: member="cunghr_m.cpp::magma_cunghr_m" ref="ga837c62a892423c53dc421c473c4aca92" args="(magma_int_t n, magma_int_t ilo, magma_int_t ihi, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *T, magma_int_t nb, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunghr_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CUNGHR generates a COMPLEX unitary matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by CGEHRD:. </p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix Q. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ilo</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ihi</em>&nbsp;</td><td>INTEGER ILO and IHI must have the same values as in the previous call of CGEHRD. Q is equal to the unit matrix except in the submatrix Q(ilo+1:ihi,ilo+1:ihi). 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by CGEHRD. On exit, the N-by-N unitary matrix Q.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>COMPLEX array, dimension (N-1) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEHRD.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>T</em>&nbsp;</td><td>COMPLEX array on the GPU device. T contains the T matrices used in blocking the elementary reflectors H(i), e.g., this can be the 9th argument of magma_cgehrd.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>INTEGER This is the block size used in CGEHRD, and correspondingly the size of the T matrices, used in the factorization, and stored in T.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Nov 2014 for MAGMA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
