<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: single-complex precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.0.2</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__cheev__2stage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">single-complex precision<div class="ingroups"><a class="el" href="group__eigenvalue.html">Eigenvalue</a> &raquo; <a class="el" href="group__magma__syev.html">Symmetric eigenvalue</a> &raquo; <a class="el" href="group__magma__syev__2stage.html">Symmetric eigenvalue: computational, 2-stage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf1fbb492481698e1b442c886c94fbb06"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cheev__2stage.html#gaf1fbb492481698e1b442c886c94fbb06">magma_chetrd_hb2st</a> (magma_uplo_t uplo, magma_int_t n, magma_int_t nb, magma_int_t Vblksiz, magmaFloatComplex *A, magma_int_t lda, float *d, float *e, magmaFloatComplex *V, magma_int_t ldv, magmaFloatComplex *TAU, magma_int_t wantz, magmaFloatComplex *T, magma_int_t ldt)</td></tr>
<tr class="separator:gaf1fbb492481698e1b442c886c94fbb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8669e0f9380c40e07277cfec5bf57af1"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cheev__2stage.html#ga8669e0f9380c40e07277cfec5bf57af1">magma_chetrd_he2hb</a> (magma_uplo_t uplo, magma_int_t n, magma_int_t nb, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magmaFloatComplex_ptr dT, magma_int_t *info)</td></tr>
<tr class="memdesc:ga8669e0f9380c40e07277cfec5bf57af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRD_HE2HB reduces a complex Hermitian matrix A to real symmetric band-diagonal form T by an orthogonal similarity transformation: Q**H * A * Q = T.  <a href="#ga8669e0f9380c40e07277cfec5bf57af1">More...</a><br /></td></tr>
<tr class="separator:ga8669e0f9380c40e07277cfec5bf57af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga684b9066d3dfae166ad81f8ea48fabf3"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cheev__2stage.html#ga684b9066d3dfae166ad81f8ea48fabf3">magma_chetrd_he2hb_mgpu</a> (magma_uplo_t uplo, magma_int_t n, magma_int_t nb, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magmaFloatComplex_ptr dAmgpu[], magma_int_t ldda, magmaFloatComplex_ptr dTmgpu[], magma_int_t lddt, magma_int_t ngpu, magma_int_t distblk, magma_queue_t queues[][20], magma_int_t nqueue, magma_int_t *info)</td></tr>
<tr class="memdesc:ga684b9066d3dfae166ad81f8ea48fabf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRD_HE2HB reduces a complex Hermitian matrix A to real symmetric band-diagonal form T by an orthogonal similarity transformation: Q**H * A * Q = T.  <a href="#ga684b9066d3dfae166ad81f8ea48fabf3">More...</a><br /></td></tr>
<tr class="separator:ga684b9066d3dfae166ad81f8ea48fabf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bac95ab48acfac1f425c6c8870ee322"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cheev__2stage.html#ga3bac95ab48acfac1f425c6c8870ee322">magma_cungqr_2stage_gpu</a> (magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex_ptr dA, magma_int_t ldda, magmaFloatComplex *tau, magmaFloatComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga3bac95ab48acfac1f425c6c8870ee322"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGQR generates an M-by-N COMPLEX matrix Q with orthonormal columns, which is defined as the first N columns of a product of K elementary reflectors of order M.  <a href="#ga3bac95ab48acfac1f425c6c8870ee322">More...</a><br /></td></tr>
<tr class="separator:ga3bac95ab48acfac1f425c6c8870ee322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdf2ca840d71f63ac0379de07422138"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__cheev__2stage.html#ga4cdf2ca840d71f63ac0379de07422138">magma_cunmqr_gpu_2stages</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex_ptr dA, magma_int_t ldda, magmaFloatComplex_ptr dC, magma_int_t lddc, magmaFloatComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga4cdf2ca840d71f63ac0379de07422138"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR_GPU overwrites the general complex M-by-N matrix C with.  <a href="#ga4cdf2ca840d71f63ac0379de07422138">More...</a><br /></td></tr>
<tr class="separator:ga4cdf2ca840d71f63ac0379de07422138"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf1fbb492481698e1b442c886c94fbb06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_chetrd_hb2st </td>
          <td>(</td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>Vblksiz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>wantz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangles of A is stored;</li>
<li>= MagmaLower: Lower triangles of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER The order of the band matrix A. n &gt;= nb &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vblksiz</td><td>INTEGER The size of the block of householder vectors applied at once.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>(workspace) COMPLEX array, dimension (lda, n) On entry the band matrix stored in the following way:</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. lda &gt;= 2*nb.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>DOUBLE array, dimension (n) The diagonal elements of the tridiagonal matrix T: D(i) = A(i,i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e</td><td>DOUBLE array, dimension (n-1) The off-diagonal elements of the tridiagonal matrix T: E(i) = A(i,i+1) if UPLO = MagmaUpper, E(i) = A(i+1,i) if UPLO = MagmaLower.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>COMPLEX array, dimension (BLKCNT, LDV, VBLKSIZ) On exit it contains the blocks of householder reflectors BLKCNT is the number of block and it is returned by the funtion MAGMA_BULGE_GET_BLKCNT.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>INTEGER The leading dimension of V. LDV &gt; nb + VBLKSIZ + 1</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAU</td><td>COMPLEX dimension(BLKCNT, VBLKSIZ) ???</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wantz</td><td>INTEGER if COMPT = 0 T is not computed if COMPT = 1 T is computed</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>COMPLEX dimension(LDT *) if COMPT = 1 on exit contains the matrices T needed for Q2 if COMPT = 0 T is not referenced</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of T. LDT &gt; Vblksiz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8669e0f9380c40e07277cfec5bf57af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_chetrd_he2hb </td>
          <td>(</td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHETRD_HE2HB reduces a complex Hermitian matrix A to real symmetric band-diagonal form T by an orthogonal similarity transformation: Q**H * A * Q = T. </p>
<p>This version stores the triangular matrices T used in the accumulated Householder transformations (I - V T V').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER The inner blocking. nb &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX array, dimension (LDA,N) On entry, the Hermitian matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if UPLO = MagmaUpper, the Upper band-diagonal of A is overwritten by the corresponding elements of the band-diagonal matrix T, and the elements above the band diagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors; if UPLO = MagmaLower, the the Lower band-diagonal of A is overwritten by the corresponding elements of the band-diagonal matrix T, and the elements below the band-diagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. LWORK &gt;= 1. For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dT</td><td>COMPLEX array on the GPU, dimension N*NB, where NB is the optimal blocksize. On exit dT holds the upper triangular matrices T from the accumulated Householder transformations (I - V T V') used in the factorization. The nb x nb matrices T are ordered consecutively in memory one after another.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>If UPLO = MagmaUpper, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(n-1) . . . H(2) H(1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a complex scalar, and v is a complex vector with v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in TAU(i).</p>
<p>If UPLO = MagmaLower, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(n-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a complex scalar, and v is a complex vector with v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i), and tau in TAU(i).</p>
<p>The contents of A on exit are illustrated by the following examples with n = 5:</p>
<p>if UPLO = MagmaUpper: if UPLO = MagmaLower:</p>
<p>( d e v2 v3 v4 ) ( d ) ( d e v3 v4 ) ( e d ) ( d e v4 ) ( v1 e d ) ( d e ) ( v1 v2 e d ) ( d ) ( v1 v2 v3 e d )</p>
<p>where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element of the vector defining H(i). </p>

</div>
</div>
<a class="anchor" id="ga684b9066d3dfae166ad81f8ea48fabf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_chetrd_he2hb_mgpu </td>
          <td>(</td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dAmgpu</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dTmgpu</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>distblk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_queue_t&#160;</td>
          <td class="paramname"><em>queues</em>[][20], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHETRD_HE2HB reduces a complex Hermitian matrix A to real symmetric band-diagonal form T by an orthogonal similarity transformation: Q**H * A * Q = T. </p>
<p>This version stores the triangular matrices T used in the accumulated Householder transformations (I - V T V').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER The inner blocking. nb &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX array, dimension (LDA,N) On entry, the Hermitian matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if UPLO = MagmaUpper, the Upper band-diagonal of A is overwritten by the corresponding elements of the band-diagonal matrix T, and the elements above the band diagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors; if UPLO = MagmaLower, the the Lower band-diagonal of A is overwritten by the corresponding elements of the band-diagonal matrix T, and the elements below the band-diagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. LWORK &gt;= 1. For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAmgpu</td><td>COMPLEX array of pointer, dimension (ngpu) Each point to a COMPLEX array, dimension (LDDA, nlocal) which hold the local matrix on each GPU.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dAmgpu. ldda &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dTmgpu</td><td>COMPLEX array of pointer, dimension (ngpu) Each point to a COMPLEX array on the GPU, dimension n*nb, where nb is the optimal blocksize. On exit dT holds the upper triangular matrices T from the accumulated Householder transformations (I - V T V') used in the factorization. The nb x nb matrices T are ordered consecutively in memory one after another.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddt</td><td>INTEGER The leading dimension of each array dT. lddt &gt;= max(1,nb).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER The number of GPUs.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distblk</td><td>INTEGER Internal parameter for performance tuning. The size of the distribution/computation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of magma_queue_t that point to the queues to be used in execution/communications. Dimension &gt;= max(3, ngpu+1) Queue to execute in.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nqueue</td><td>INTEGER The number of queues should be &gt;= max(3, ngpu+1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>If UPLO = MagmaUpper, the matrix Q is represented as a product of elementary reflectors </p><pre class="fragment">Q = H(n-1) . . . H(2) H(1).
</pre><p>Each H(i) has the form </p><pre class="fragment">H(i) = I - tau * v * v'
</pre><p>where tau is a complex scalar, and v is a complex vector with v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in TAU(i).</p>
<p>If UPLO = MagmaLower, the matrix Q is represented as a product of elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(n-1).
</pre><p>Each H(i) has the form </p><pre class="fragment">H(i) = I - tau * v * v'
</pre><p>where tau is a complex scalar, and v is a complex vector with v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i), and tau in TAU(i).</p>
<p>The contents of A on exit are illustrated by the following examples with n = 5:</p>
<p>if UPLO = MagmaUpper: if UPLO = MagmaLower: </p><pre class="fragment">(  d   e   v2  v3  v4 )              (  d                  )
(      d   e   v3  v4 )              (  e   d              )
(          d   e   v4 )              (  v1  e   d          )
(              d   e  )              (  v1  v2  e   d      )
(                  d  )              (  v1  v2  v3  e   d  )
</pre><p>where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element of the vector defining H(i). </p>

</div>
</div>
<a class="anchor" id="ga3bac95ab48acfac1f425c6c8870ee322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cungqr_2stage_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNGQR generates an M-by-N COMPLEX matrix Q with orthonormal columns, which is defined as the first N columns of a product of K elementary reflectors of order M. </p>
<p>Q = H(1) H(2) . . . H(k)</p>
<p>as returned by CGEQRF_GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix Q. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix Q. M &gt;= N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>COMPLEX array A on the GPU device, dimension (LDDA,N). On entry, the i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF_GPU in the first k columns of its array argument A. On exit, the M-by-N matrix Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The first dimension of the array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEQRF_GPU.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>COMPLEX work space array on the GPU device, dimension (MIN(M, N) )*NB. This must be the 6th argument of magma_cgeqrf_gpu [ note that if N here is bigger than N in magma_cgeqrf_gpu, the workspace requirement DT in magma_cgeqrf_gpu must be as specified in this routine ].</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the block size used in CGEQRF_GPU, and correspondingly the size of the T matrices, used in the factorization, and stored in DT.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4cdf2ca840d71f63ac0379de07422138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunmqr_gpu_2stages </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNMQR_GPU overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by CGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>COMPLEX array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF in the first k columns of its array argument DA. DA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>COMPLEX array on the GPU that is the output (the 9th argument) of magma_cgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_cgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon May 2 2016 23:31:43 for MAGMA by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
