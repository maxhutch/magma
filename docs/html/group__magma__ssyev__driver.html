<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>MAGMA: single precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__ssyev__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">single precision<div class="ingroups"><a class="el" href="group__magma__syev__driver.html">Symmetric eigenvalue: driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8af9f0938c55eb4cb60db488019fcb9a"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#ga8af9f0938c55eb4cb60db488019fcb9a">magma_ssyevd</a> (magma_vec_t jobz, magma_uplo_t uplo, magma_int_t n, float *A, magma_int_t lda, float *w, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga8af9f0938c55eb4cb60db488019fcb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <a href="#ga8af9f0938c55eb4cb60db488019fcb9a">More...</a><br /></td></tr>
<tr class="separator:ga8af9f0938c55eb4cb60db488019fcb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e04d22e62b72b7af89cee097c4fe1a"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#gaa7e04d22e62b72b7af89cee097c4fe1a">magma_ssyevd_gpu</a> (magma_vec_t jobz, magma_uplo_t uplo, magma_int_t n, float *dA, magma_int_t ldda, float *w, float *wA, magma_int_t ldwa, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaa7e04d22e62b72b7af89cee097c4fe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVD_GPU computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <a href="#gaa7e04d22e62b72b7af89cee097c4fe1a">More...</a><br /></td></tr>
<tr class="separator:gaa7e04d22e62b72b7af89cee097c4fe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8853afbb2607f421514483be84f644db"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#ga8853afbb2607f421514483be84f644db">magma_ssyevd_m</a> (magma_int_t nrgpu, magma_vec_t jobz, magma_uplo_t uplo, magma_int_t n, float *A, magma_int_t lda, float *w, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga8853afbb2607f421514483be84f644db"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <a href="#ga8853afbb2607f421514483be84f644db">More...</a><br /></td></tr>
<tr class="separator:ga8853afbb2607f421514483be84f644db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94556e48d82b80fee8f97751019d3a97"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#ga94556e48d82b80fee8f97751019d3a97">magma_ssyevdx</a> (magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, float *A, magma_int_t lda, float vl, float vu, magma_int_t il, magma_int_t iu, magma_int_t *m, float *w, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga94556e48d82b80fee8f97751019d3a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVDX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <a href="#ga94556e48d82b80fee8f97751019d3a97">More...</a><br /></td></tr>
<tr class="separator:ga94556e48d82b80fee8f97751019d3a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252ba5cbdc20c348b1111bc45563adc8"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#ga252ba5cbdc20c348b1111bc45563adc8">magma_ssyevdx_2stage</a> (magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, float *A, magma_int_t lda, float vl, float vu, magma_int_t il, magma_int_t iu, magma_int_t *m, float *w, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga252ba5cbdc20c348b1111bc45563adc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZHEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A.  <a href="#ga252ba5cbdc20c348b1111bc45563adc8">More...</a><br /></td></tr>
<tr class="separator:ga252ba5cbdc20c348b1111bc45563adc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d24fa79703f5e614df4be662a6f0347"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#ga1d24fa79703f5e614df4be662a6f0347">magma_ssyevdx_2stage_m</a> (magma_int_t nrgpu, magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, float *A, magma_int_t lda, float vl, float vu, magma_int_t il, magma_int_t iu, magma_int_t *m, float *w, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga1d24fa79703f5e614df4be662a6f0347"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZHEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A.  <a href="#ga1d24fa79703f5e614df4be662a6f0347">More...</a><br /></td></tr>
<tr class="separator:ga1d24fa79703f5e614df4be662a6f0347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec483500b8e2f152d48a1e78bd36e8c7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#gaec483500b8e2f152d48a1e78bd36e8c7">magma_ssyevdx_gpu</a> (magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, float *dA, magma_int_t ldda, float vl, float vu, magma_int_t il, magma_int_t iu, magma_int_t *m, float *w, float *wA, magma_int_t ldwa, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaec483500b8e2f152d48a1e78bd36e8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVDX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <a href="#gaec483500b8e2f152d48a1e78bd36e8c7">More...</a><br /></td></tr>
<tr class="separator:gaec483500b8e2f152d48a1e78bd36e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f50ba1d0b0ae828701d15ce16ae631"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ssyev__driver.html#gaa5f50ba1d0b0ae828701d15ce16ae631">magma_ssyevdx_m</a> (magma_int_t nrgpu, magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, float *A, magma_int_t lda, float vl, float vu, magma_int_t il, magma_int_t iu, magma_int_t *m, float *w, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaa5f50ba1d0b0ae828701d15ce16ae631"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <a href="#gaa5f50ba1d0b0ae828701d15ce16ae631">More...</a><br /></td></tr>
<tr class="separator:gaa5f50ba1d0b0ae828701d15ce16ae631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8af9f0938c55eb4cb60db488019fcb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. </p>
<p>If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>REAL array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= 2*N + N*NB. If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= max( 2*N + N*NB, 1 + 6*N + 2*N**2 ). NB can be obtained through magma_get_ssytrd_nb(N). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="gaa7e04d22e62b72b7af89cee097c4fe1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevd_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldwa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSYEVD_GPU computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. </p>
<p>If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>REAL array on the GPU, dimension (LDDA, N). On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">wA</td><td>(workspace) REAL array, dimension (LDWA, N)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldwa</td><td>INTEGER The leading dimension of the array wA. LDWA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= 2*N + N*NB. If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= max( 2*N + N*NB, 1 + 6*N + 2*N**2 ). NB can be obtained through magma_get_ssytrd_nb(N). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="ga8853afbb2607f421514483be84f644db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevd_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrgpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. </p>
<p>If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrgpu</td><td>INTEGER Number of GPUs to use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>REAL array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= N * (NB + 1). If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= 2*N + N**2. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="ga94556e48d82b80fee8f97751019d3a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevdx </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSYEVDX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. </p>
<p>Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>REAL array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the required m eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= 2*N + N*NB. If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= max( 2*N + N*NB, 1 + 6*N + 2*N**2 ). NB can be obtained through magma_get_ssytrd_nb(N). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="ga252ba5cbdc20c348b1111bc45563adc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevdx_2stage </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZHEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. </p>
<p>It uses a two-stage algorithm for the tridiagonalization. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX_16 array, dimension (LDA, N) On entry, the Hermitian matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, the first m columns of A contains the required orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the required m eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX_16 array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= LQ2 + N * (NB + 2). If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= LQ2 + 1 + 6*N + 2*N**2. where LQ2 is the size needed to store the Q2 matrix and is returned by magma_bulge_get_lq2. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="ga1d24fa79703f5e614df4be662a6f0347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevdx_2stage_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrgpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZHEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. </p>
<p>It uses a two-stage algorithm for the tridiagonalization. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrgpu</td><td>INTEGER Number of GPUs to use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX_16 array, dimension (LDA, N) On entry, the Hermitian matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, the first m columns of A contains the required orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the required m eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX_16 array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= LQ2 + N * (NB + 2). If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= LQ2 + 1 + 6*N + 2*N**2. where LQ2 is the size needed to store the Q2 matrix and is returned by magma_bulge_get_lq2. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="gaec483500b8e2f152d48a1e78bd36e8c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevdx_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldwa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSYEVDX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. </p>
<p>Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>REAL array on the GPU, dimension (LDDA, N). On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, the first m columns of A contains the required orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the required m eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">wA</td><td>(workspace) REAL array, dimension (LDWA, N)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldwa</td><td>INTEGER The leading dimension of the array wA. LDWA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= 2*N + N*NB. If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= max( 2*N + N*NB, 1 + 6*N + 2*N**2 ). NB can be obtained through magma_get_ssytrd_nb(N). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
<a class="anchor" id="gaa5f50ba1d0b0ae828701d15ce16ae631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ssyevdx_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrgpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. </p>
<p>If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrgpu</td><td>INTEGER Number of GPUs to use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangle of A is stored;</li>
<li>= MagmaLower: Lower triangle of A is stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>REAL array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = MagmaVec, then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = MagmaNoVec, then on exit the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LWORK &gt;= N * (NB + 1). If JOBZ = MagmaVec and N &gt; 1, LWORK &gt;= 2*N + N**2. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = MagmaNoVec and N &gt; 1, LIWORK &gt;= 1. If JOBZ = MagmaVec and N &gt; 1, LIWORK &gt;= 3 + 5*N. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i and JOBZ = MagmaNoVec, then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = MagmaVec, then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA</p>
<p>Modified description of INFO. Sven, 16 Feb 05. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jul 18 2014 17:34:43 for MAGMA by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
